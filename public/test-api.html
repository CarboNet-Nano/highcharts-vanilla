<!DOCTYPE html>
<html>
  <head>
    <title>Highcharts Real-time Chart</title>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://js.pusher.com/8.2/pusher.min.js"></script>
    <link rel="stylesheet" href="styles.css" />
    <style>
      #chart-container {
        opacity: 0;
        transition: opacity 0.3s ease-in;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 300px;
      }
      #chart-container.ready {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="chart-container">Loading chart...</div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        let chartInstance = null;
        let isInitialized = false;

        function initializeWithMode() {
          try {
            const url = new URL(window.location.href);
            const params = new URLSearchParams(url.search);
            let mode = params.get("mode") || "light";

            mode = mode === "dark" || mode === "light" ? mode : "light";

            document.documentElement.className = `theme-${mode}`;
            initializeChart(mode);
          } catch (error) {
            console.error("Error parsing URL:", error);
            initializeChart("light");
          }
        }

        const pusher = new Pusher("809e85ce5d8ffdc09f9d", {
          cluster: "us3",
        });

        const channel = pusher.subscribe("chart-updates");

        function getColorForValue(value) {
          if (value <= 15) return "#D32F2F";
          if (value <= 45) return "#FFCA28";
          return "#388E3C";
        }

        function updateTheme(mode) {
          if (mode !== "dark" && mode !== "light") return;

          document.documentElement.className = `theme-${mode}`;
          if (chartInstance) {
            const theme = {
              light: { background: "#ffffff", text: "#000000" },
              dark: { background: "#121212", text: "#ffffff" },
            }[mode];

            chartInstance.update(
              {
                chart: {
                  backgroundColor: theme.background,
                  style: { color: theme.text },
                },
                xAxis: {
                  labels: { style: { color: theme.text } },
                  lineColor: theme.text,
                  tickColor: theme.text,
                  gridLineWidth: 0,
                },
                yAxis: {
                  labels: { style: { color: theme.text } },
                  gridLineColor: theme.text,
                  lineColor: theme.text,
                  gridLineWidth: 0,
                },
                plotOptions: {
                  column: {
                    dataLabels: {
                      style: { color: theme.text },
                    },
                  },
                },
              },
              true
            );
          }
        }

        function createChart(initialValues, mode) {
          if (chartInstance) return;

          const theme = {
            light: { background: "#ffffff", text: "#000000" },
            dark: { background: "#121212", text: "#ffffff" },
          }[mode];

          const container = document.getElementById("chart-container");

          container.style.backgroundColor = theme.background;
          container.style.color = theme.text;

          chartInstance = Highcharts.chart(container, {
            chart: {
              type: "column",
              animation: false,
              height: container.clientHeight || 300,
              width: container.clientWidth || 400,
              backgroundColor: theme.background,
              style: { color: theme.text },
            },
            title: { text: null },
            xAxis: {
              categories: ["No Boost", "No Makedown", "Makedown"],
              labels: { style: { color: theme.text } },
              gridLineWidth: 0,
              lineColor: theme.text,
              tickColor: theme.text,
            },
            yAxis: {
              title: { text: "Percentage" },
              labels: {
                format: "{value}%",
                style: { color: theme.text },
              },
              gridLineWidth: 0,
              lineColor: theme.text,
              gridLineColor: theme.text,
            },
            plotOptions: {
              column: {
                animation: false,
                dataLabels: {
                  enabled: true,
                  format: "{y:.1f}%",
                  style: { color: theme.text },
                },
              },
            },
            series: [
              {
                name: "Values",
                data: initialValues.map((value) => ({
                  y: value,
                  color: getColorForValue(value),
                })),
              },
            ],
          });

          container.classList.add("ready");
        }

        async function fetchInitialData(mode) {
          if (isInitialized) return null;

          try {
            const response = await fetch(
              "/.netlify/functions/get-chart-values",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  type: "initial-load",
                  mode: mode,
                }),
              }
            );

            const data = await response.json();
            console.log("Initial data received:", data);

            if (data.success && data.values) {
              localStorage.setItem("chartData", JSON.stringify(data.values));
              localStorage.setItem(
                "lastUpdateTime",
                new Date(data.timestamp).getTime()
              );
              return data.values;
            }

            throw new Error("Invalid data received");
          } catch (error) {
            console.error("Failed to fetch initial values:", error);
            const storedData = localStorage.getItem("chartData");
            return storedData ? JSON.parse(storedData) : [0, 0, 0];
          }
        }

        async function initializeChart(mode) {
          if (isInitialized) return;

          const container = document.getElementById("chart-container");
          container.style.backgroundColor =
            mode === "dark" ? "#121212" : "#ffffff";
          container.style.color = mode === "dark" ? "#ffffff" : "#000000";

          const values = await fetchInitialData(mode);
          if (values) {
            createChart(values, mode);
            container.classList.add("ready");
            isInitialized = true;
          }

          channel.bind("value-update", function (data) {
            console.log("Pusher update received:", data);
            if (data.source === "sync-check") return;

            if (data.type === "update") {
              const lastUpdate = localStorage.getItem("lastUpdateTime");
              const newTimestamp = new Date(data.timestamp).getTime();

              if (!lastUpdate || newTimestamp > parseInt(lastUpdate)) {
                if (data.values) {
                  localStorage.setItem(
                    "chartData",
                    JSON.stringify(data.values)
                  );
                  localStorage.setItem("lastUpdateTime", newTimestamp);

                  const chartData = data.values.map((value) => ({
                    y: Number(value),
                    color: getColorForValue(Number(value)),
                  }));

                  chartData.forEach((point, index) => {
                    chartInstance.series[0].points[index].update(point, false);
                  });

                  chartInstance.redraw(true);
                }

                if (data.mode) {
                  updateTheme(data.mode);
                }
              }
            }
          });

          let resizeTimeout;
          window.addEventListener("resize", function () {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              chartInstance.setSize(
                container.clientWidth,
                container.clientHeight
              );
            }, 100);
          });
        }

        initializeWithMode();
      });
    </script>
  </body>
</html>
