<!DOCTYPE html>
<html>
  <head>
    <title>Highcharts Real-time Chart</title>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://js.pusher.com/8.0/pusher.min.js"></script>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #chart-container {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="chart-container"></div>

    <script>
      const pusher = new Pusher("809e85ce5d8ffdc09f9d", {
        cluster: "us3",
      });

      const channel = pusher.subscribe("chart-updates");

      function getColorForValue(value) {
        if (value <= 15) return "#D32F2F";
        if (value <= 45) return "#FFCA28";
        return "#388E3C";
      }

      async function verifyAndUpdateChart(chart) {
        try {
          const currentValues = chart.series[0].points.map((point) => point.y);

          const response = await fetch("/.netlify/functions/get-chart-values", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              type: "sync-check",
              values: currentValues,
              no_boost: currentValues[0],
              no_makedown: currentValues[1],
              makedown: currentValues[2],
            }),
          });

          const data = await response.json();

          if (data.success && data.values) {
            const currentChartValues = chart.series[0].points.map(
              (point) => point.y
            );
            const newValues = data.values;

            // Check if values are different
            const needsUpdate = currentChartValues.some(
              (value, index) => Math.abs(value - newValues[index]) > 0.1
            );

            if (needsUpdate) {
              console.log(
                "Chart out of sync, updating with server values:",
                newValues
              );
              const chartData = newValues.map((value) => ({
                y: Number(value),
                color: getColorForValue(Number(value)),
              }));

              chartData.forEach((point, index) => {
                chart.series[0].points[index].update(point, false);
              });

              chart.redraw();
              localStorage.setItem("chartData", JSON.stringify(newValues));
              localStorage.setItem(
                "lastUpdateTime",
                new Date(data.timestamp).getTime()
              );
            }
          }
        } catch (error) {
          console.error("Sync check failed:", error);
        }
      }

      async function fetchInitialData() {
        try {
          // Try to get stored values first
          const storedData = localStorage.getItem("chartData");
          const lastUpdate = localStorage.getItem("lastUpdateTime");
          let currentValues = storedData
            ? JSON.parse(storedData)
            : [35.1, 46.3, 78.7];

          const response = await fetch("/.netlify/functions/get-chart-values", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              type: "initial-load",
            }),
          });

          const data = await response.json();
          console.log("Initial data received:", data);

          if (data.success && data.values) {
            localStorage.setItem("chartData", JSON.stringify(data.values));
            localStorage.setItem(
              "lastUpdateTime",
              new Date(data.timestamp).getTime()
            );
            return data.values;
          }
          return currentValues;
        } catch (error) {
          console.error("Failed to fetch initial values:", error);
          const storedData = localStorage.getItem("chartData");
          return storedData ? JSON.parse(storedData) : [0, 0, 0];
        }
      }

      async function createChart() {
        const initialValues = await fetchInitialData();
        console.log("Creating chart with values:", initialValues);

        const container = document.getElementById("chart-container");
        let chart = Highcharts.chart(container, {
          chart: {
            type: "column",
            animation: false,
            height: container.clientHeight,
            width: container.clientWidth,
          },
          title: {
            text: null,
          },
          xAxis: {
            categories: ["No Boost", "No Makedown", "Makedown"],
          },
          yAxis: {
            title: {
              text: "Percentage",
            },
            labels: {
              format: "{value}%",
            },
          },
          plotOptions: {
            column: {
              animation: false,
              dataLabels: {
                enabled: true,
                format: "{y:.1f}%",
              },
            },
          },
          series: [
            {
              name: "Values",
              data: initialValues.map((value) => ({
                y: value,
                color: getColorForValue(value),
              })),
            },
          ],
        });

        channel.bind("value-update", function (data) {
          console.log("Pusher update received:", data);
          if (data.type === "update" && Array.isArray(data.values)) {
            const lastUpdate = localStorage.getItem("lastUpdateTime");
            const newTimestamp = new Date(data.timestamp).getTime();

            if (!lastUpdate || newTimestamp > parseInt(lastUpdate)) {
              localStorage.setItem("chartData", JSON.stringify(data.values));
              localStorage.setItem("lastUpdateTime", newTimestamp);

              const chartData = data.values.map((value) => ({
                y: Number(value),
                color: getColorForValue(Number(value)),
              }));

              chartData.forEach((point, index) => {
                chart.series[0].points[index].update(point, false);
              });

              chart.redraw();

              // Only verify after we get a new update
              verifyAndUpdateChart(chart);
            } else {
              console.log("Skipping outdated update", {
                current: new Date(parseInt(lastUpdate)).toISOString(),
                received: new Date(newTimestamp).toISOString(),
              });
            }
          }
        });

        let resizeTimeout;
        window.addEventListener("resize", function () {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            chart.setSize(container.clientWidth, container.clientHeight);
            chart.redraw();
          }, 100);
        });
      }

      document.addEventListener("DOMContentLoaded", createChart);
    </script>
  </body>
</html>
